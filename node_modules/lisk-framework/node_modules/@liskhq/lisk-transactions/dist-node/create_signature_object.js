"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cryptography = require("@liskhq/lisk-cryptography");
const _10_delegate_transaction_1 = require("./10_delegate_transaction");
const _11_vote_transaction_1 = require("./11_vote_transaction");
const _12_multisignature_transaction_1 = require("./12_multisignature_transaction");
const _8_transfer_transaction_1 = require("./8_transfer_transaction");
const _9_second_signature_transaction_1 = require("./9_second_signature_transaction");
const transactionMap = {
    8: _8_transfer_transaction_1.TransferTransaction,
    9: _9_second_signature_transaction_1.SecondSignatureTransaction,
    10: _10_delegate_transaction_1.DelegateTransaction,
    11: _11_vote_transaction_1.VoteTransaction,
    12: _12_multisignature_transaction_1.MultisignatureTransaction,
};
exports.createSignatureObject = (options) => {
    const { transaction, passphrase, networkIdentifier } = options;
    if (transaction.type === undefined || transaction.type === null) {
        throw new Error('Transaction type is required.');
    }
    if (!Object.keys(transactionMap).includes(String(transaction.type))) {
        throw new Error('Invalid transaction type.');
    }
    if (!transaction.id) {
        throw new Error('Transaction ID is required to create a signature object.');
    }
    const TransactionClass = transactionMap[transaction.type];
    const tx = new TransactionClass({
        ...transaction,
        networkIdentifier,
    });
    const validStatus = tx.validate();
    if (validStatus.errors.length > 0) {
        throw new Error('Invalid transaction.');
    }
    const { publicKey } = cryptography.getPrivateAndPublicKeyFromPassphrase(passphrase);
    tx._signature = undefined;
    tx._signSignature = undefined;
    const networkIdentifierBytes = Buffer.from(networkIdentifier, 'hex');
    const transactionWithNetworkIdentifierBytes = Buffer.concat([
        networkIdentifierBytes,
        tx.getBytes(),
    ]);
    const multiSignature = cryptography.signData(cryptography.hash(transactionWithNetworkIdentifierBytes), passphrase);
    return {
        transactionId: tx.id,
        publicKey,
        signature: multiSignature,
    };
};
//# sourceMappingURL=create_signature_object.js.map