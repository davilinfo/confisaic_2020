/// <reference types="node" />
import { EventEmitter } from 'events';
import * as socketClusterClient from 'socketcluster-client';
import { SCServerSocket } from 'socketcluster-server';
import { P2PInternalState, P2PMessagePacket, P2PNodeInfo, P2PPeerInfo, P2PRequestPacket, P2PResponsePacket } from '../p2p_types';
export declare const socketErrorStatusCodes: any;
export declare type SCClientSocket = socketClusterClient.SCClientSocket;
export declare type SCServerSocketUpdated = {
    destroy(code?: number, data?: string | object): void;
    on(event: string | unknown, listener: (packet?: unknown) => void): void;
    on(event: string, listener: (packet: any, respond: any) => void): void;
} & SCServerSocket;
export declare enum ConnectionState {
    CONNECTING = "connecting",
    OPEN = "open",
    CLOSED = "closed"
}
export interface ConnectedPeerInfo extends P2PPeerInfo {
    internalState: P2PInternalState;
}
export interface PeerConfig {
    readonly connectTimeout?: number;
    readonly ackTimeout?: number;
    readonly rateCalculationInterval: number;
    readonly wsMaxMessageRate: number;
    readonly wsMaxMessageRatePenalty: number;
    readonly wsMaxPayload?: number;
    readonly maxPeerInfoSize: number;
    readonly maxPeerDiscoveryResponseLength: number;
    readonly secret: number;
    readonly serverNodeInfo?: P2PNodeInfo;
}
export declare class Peer extends EventEmitter {
    private readonly _counterResetInterval;
    protected _peerInfo: ConnectedPeerInfo;
    private readonly _productivityResetInterval;
    protected readonly _peerConfig: PeerConfig;
    protected _serverNodeInfo: P2PNodeInfo | undefined;
    protected _rateInterval: number;
    protected readonly _handleRawRPC: (packet: unknown, respond: (responseError?: Error, responseData?: unknown) => void) => void;
    protected readonly _handleWSMessage: (message: string) => void;
    protected readonly _handleRawMessage: (packet: unknown) => void;
    protected _socket: SCServerSocketUpdated | SCClientSocket | undefined;
    constructor(peerInfo: P2PPeerInfo, peerConfig: PeerConfig);
    get id(): string;
    get ipAddress(): string;
    get wsPort(): number;
    get internalState(): P2PInternalState;
    get state(): ConnectionState;
    updateInternalState(internalState: P2PInternalState): void;
    get peerInfo(): ConnectedPeerInfo;
    private _initializeInternalState;
    updatePeerInfo(newPeerInfo: P2PPeerInfo): void;
    connect(): void;
    disconnect(code?: number, reason?: string): void;
    send(packet: P2PMessagePacket): void;
    request(packet: P2PRequestPacket): Promise<P2PResponsePacket>;
    fetchPeers(): Promise<ReadonlyArray<P2PPeerInfo>>;
    discoverPeers(): Promise<ReadonlyArray<P2PPeerInfo>>;
    fetchAndUpdateStatus(): Promise<P2PPeerInfo>;
    applyPenalty(penalty: number): void;
    private _resetCounters;
    private _resetProductivity;
    private _updateFromProtocolPeerInfo;
    private _handleUpdatePeerInfo;
    private _banPeer;
    private _updateRPCCounter;
    private _getRPCRate;
    private _updateMessageCounter;
    private _getMessageRate;
}
