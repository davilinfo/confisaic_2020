/// <reference types="node" />
import * as BigNum from '@liskhq/bignum';
import { DelegateTransaction } from './10_delegate_transaction';
import { VoteTransaction } from './11_vote_transaction';
import { MultisignatureTransaction } from './12_multisignature_transaction';
import { TransferTransaction } from './8_transfer_transaction';
import { SecondSignatureTransaction } from './9_second_signature_transaction';
import { BaseTransaction, StateStore, StateStorePrepare } from './base_transaction';
import { castVotes } from './cast_votes';
import * as constants from './constants';
import { createSignatureObject, SignatureObject } from './create_signature_object';
import { convertToAssetError, convertToTransactionError, TransactionError, TransactionPendingError } from './errors';
import { registerDelegate } from './register_delegate';
import { registerMultisignature } from './register_multisignature_account';
import { registerSecondPassphrase } from './register_second_passphrase';
import { createResponse, Status, TransactionResponse } from './response';
import { transactionInterface } from './schema';
import { Account, TransactionJSON } from './transaction_types';
import { transfer } from './transfer';
declare const exposedUtils: {
    BigNum: typeof BigNum;
    convertBeddowsToLSK: (beddowsAmount?: string | undefined) => string;
    getId: (transactionBytes: Buffer) => string;
    getTimeFromBlockchainEpoch: (givenTimestamp?: number | undefined) => number;
    convertLSKToBeddows: (lskAmount?: string | undefined) => string;
    prependMinusToPublicKeys: (publicKeys: readonly string[]) => readonly string[];
    prependPlusToPublicKeys: (publicKeys: readonly string[]) => readonly string[];
    validateMultisignatures: (publicKeys: readonly string[], signatures: readonly string[], minimumValidations: number, transactionBytes: Buffer, id?: string | undefined) => import("./transaction_types").IsValidResponse;
    validateSignature: (publicKey: string, signature: string, transactionBytes: Buffer, id?: string | undefined) => import("./transaction_types").IsValidResponseWithError;
    verifyAmountBalance: (id: string, account: Account, amount: BigNum, fee: BigNum) => TransactionError | undefined;
    validateSenderIdAndPublicKey: (id: string, senderId: string, senderPublicKey: string) => TransactionError | undefined;
    verifyBalance: (id: string, account: Account, amount: BigNum) => TransactionError | undefined;
    verifyMultiSignatures: (id: string, sender: Account, signatures: readonly string[], transactionBytes: Buffer) => import("./utils").VerifyMultiSignatureResult;
    verifySecondSignature: (id: string, sender: Account, signSignature: string | undefined, transactionBytes: Buffer) => TransactionError | undefined;
    verifySenderPublicKey: (id: string, sender: Account, publicKey: string) => TransactionError | undefined;
};
export { Account, BaseTransaction, StateStore, StateStorePrepare, TransferTransaction, transfer, SecondSignatureTransaction, registerSecondPassphrase, DelegateTransaction, registerDelegate, VoteTransaction, castVotes, MultisignatureTransaction, createResponse, registerMultisignature, createSignatureObject, SignatureObject, Status, TransactionResponse, TransactionJSON, TransactionError, TransactionPendingError, transactionInterface, convertToAssetError, convertToTransactionError, constants, exposedUtils as utils, };
