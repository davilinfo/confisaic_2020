"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BigNum = require("@liskhq/bignum");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const response_1 = require("./response");
const schemas = require("./schema");
const utils_1 = require("./utils");
var MultisignatureStatus;
(function (MultisignatureStatus) {
    MultisignatureStatus[MultisignatureStatus["UNKNOWN"] = 0] = "UNKNOWN";
    MultisignatureStatus[MultisignatureStatus["NONMULTISIGNATURE"] = 1] = "NONMULTISIGNATURE";
    MultisignatureStatus[MultisignatureStatus["PENDING"] = 2] = "PENDING";
    MultisignatureStatus[MultisignatureStatus["READY"] = 3] = "READY";
    MultisignatureStatus[MultisignatureStatus["FAIL"] = 4] = "FAIL";
})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));
exports.ENTITY_ACCOUNT = 'account';
exports.ENTITY_TRANSACTION = 'transaction';
class BaseTransaction {
    constructor(rawTransaction) {
        this._multisignatureStatus = MultisignatureStatus.UNKNOWN;
        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null
            ? rawTransaction
            : {});
        this.fee = new BigNum(this.constructor.FEE);
        this.type =
            typeof tx.type === 'number'
                ? tx.type
                : this.constructor.TYPE;
        this._id = tx.id;
        this._senderPublicKey = tx.senderPublicKey || '';
        this._signature = tx.signature;
        this.signatures = tx.signatures || [];
        this._signSignature = tx.signSignature;
        this._networkIdentifier = tx.networkIdentifier || '';
        this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;
        this.confirmations = tx.confirmations;
        this.blockId = tx.blockId;
        this.height = tx.height;
        this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;
        this.asset = tx.asset || {};
    }
    get id() {
        return this._id || 'incalculable-id';
    }
    get senderId() {
        return lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);
    }
    get senderPublicKey() {
        if (!this._senderPublicKey) {
            throw new Error('senderPublicKey is required to be set before use');
        }
        return this._senderPublicKey;
    }
    get signature() {
        if (!this._signature) {
            throw new Error('signature is required to be set before use');
        }
        return this._signature;
    }
    get signSignature() {
        return this._signSignature;
    }
    toJSON() {
        const transaction = {
            id: this._id,
            blockId: this.blockId,
            height: this.height,
            confirmations: this.confirmations,
            type: this.type,
            timestamp: this.timestamp,
            senderPublicKey: this._senderPublicKey || '',
            senderId: this._senderPublicKey ? this.senderId : '',
            fee: this.fee.toString(),
            signature: this._signature,
            signSignature: this.signSignature ? this.signSignature : undefined,
            signatures: this.signatures,
            asset: this.assetToJSON(),
            receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined,
        };
        return transaction;
    }
    stringify() {
        return JSON.stringify(this.toJSON());
    }
    isReady() {
        return (this._multisignatureStatus === MultisignatureStatus.READY ||
            this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE);
    }
    getBytes() {
        const transactionBytes = Buffer.concat([
            this.getBasicBytes(),
            this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0),
            this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0),
        ]);
        return transactionBytes;
    }
    validate() {
        const errors = [...this._validateSchema(), ...this.validateAsset()];
        if (errors.length > 0) {
            return response_1.createResponse(this.id, errors);
        }
        const transactionBytes = this.getBasicBytes();
        if (this._networkIdentifier === undefined ||
            this._networkIdentifier === '') {
            throw new Error('Network identifier is required to validate a transaction ');
        }
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        this._id = utils_1.getId(this.getBytes());
        const { valid: signatureValid, error: verificationError, } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionWithNetworkIdentifierBytes, this.id);
        if (!signatureValid && verificationError) {
            errors.push(verificationError);
        }
        if (this.type !== this.constructor.TYPE) {
            errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));
        }
        return response_1.createResponse(this.id, errors);
    }
    verifyAgainstTransactions(_) {
        return [];
    }
    verifyAgainstOtherTransactions(transactions) {
        const errors = this.verifyAgainstTransactions(transactions);
        return response_1.createResponse(this.id, errors);
    }
    apply(store) {
        const sender = store.account.getOrDefault(this.senderId);
        const errors = this._verify(sender);
        const { errors: multiSigError } = this.processMultisignatures(store);
        if (multiSigError) {
            errors.push(...multiSigError);
        }
        const updatedBalance = new BigNum(sender.balance).sub(this.fee);
        const updatedSender = {
            ...sender,
            balance: updatedBalance.toString(),
            publicKey: sender.publicKey || this.senderPublicKey,
        };
        store.account.set(updatedSender.address, updatedSender);
        const assetErrors = this.applyAsset(store);
        errors.push(...assetErrors);
        if (this._multisignatureStatus === MultisignatureStatus.PENDING &&
            errors.length === 1 &&
            errors[0] instanceof errors_1.TransactionPendingError) {
            return {
                id: this.id,
                status: response_1.Status.PENDING,
                errors,
            };
        }
        return response_1.createResponse(this.id, errors);
    }
    undo(store) {
        const sender = store.account.getOrDefault(this.senderId);
        const updatedBalance = new BigNum(sender.balance).add(this.fee);
        const updatedAccount = {
            ...sender,
            balance: updatedBalance.toString(),
            publicKey: sender.publicKey || this.senderPublicKey,
        };
        const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT)
            ? []
            : [
                new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString()),
            ];
        store.account.set(updatedAccount.address, updatedAccount);
        const assetErrors = this.undoAsset(store);
        errors.push(...assetErrors);
        return response_1.createResponse(this.id, errors);
    }
    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId,
            },
        ]);
    }
    addMultisignature(store, signatureObject) {
        const account = store.account.get(this.senderId);
        if (account.membersPublicKeys &&
            !account.membersPublicKeys.includes(signatureObject.publicKey)) {
            return response_1.createResponse(this.id, [
                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id),
            ]);
        }
        if (this.signatures.includes(signatureObject.signature)) {
            return response_1.createResponse(this.id, [
                new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id),
            ]);
        }
        const transactionBytes = this.getBasicBytes();
        if (this._networkIdentifier === undefined ||
            this._networkIdentifier === '') {
            throw new Error('Network identifier is required to validate a transaction ');
        }
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);
        if (valid) {
            this.signatures.push(signatureObject.signature);
            return this.processMultisignatures(store);
        }
        const errors = valid
            ? []
            : [
                new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures'),
            ];
        return response_1.createResponse(this.id, errors);
    }
    addVerifiedMultisignature(signature) {
        if (!this.signatures.includes(signature)) {
            this.signatures.push(signature);
            return response_1.createResponse(this.id, []);
        }
        return response_1.createResponse(this.id, [
            new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures'),
        ]);
    }
    processMultisignatures(store) {
        const sender = store.account.get(this.senderId);
        const transactionBytes = this.getBasicBytes();
        if (this._networkIdentifier === undefined ||
            this._networkIdentifier === '') {
            throw new Error('Network identifier is required to validate a transaction ');
        }
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        const { status, errors } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionWithNetworkIdentifierBytes);
        this._multisignatureStatus = status;
        if (this._multisignatureStatus === MultisignatureStatus.PENDING) {
            return {
                id: this.id,
                status: response_1.Status.PENDING,
                errors,
            };
        }
        return response_1.createResponse(this.id, errors);
    }
    isExpired(date = new Date()) {
        if (!this.receivedAt) {
            this.receivedAt = new Date();
        }
        const timeNow = Math.floor(date.getTime() / 1000);
        const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING ||
            this._multisignatureStatus === MultisignatureStatus.READY
            ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT
            : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;
        const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);
        return timeElapsed > timeOut;
    }
    sign(passphrase, secondPassphrase) {
        const { publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);
        if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {
            throw new Error('Transaction senderPublicKey does not match public key from passphrase');
        }
        this._senderPublicKey = publicKey;
        this._signature = undefined;
        this._signSignature = undefined;
        if (this._networkIdentifier === undefined ||
            this._networkIdentifier === '') {
            throw new Error('Network identifier is required to sign a transaction ');
        }
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            this.getBytes(),
        ]);
        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(transactionWithNetworkIdentifierBytes), passphrase);
        if (secondPassphrase) {
            this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(Buffer.concat([
                transactionWithNetworkIdentifierBytes,
                lisk_cryptography_1.hexToBuffer(this._signature),
            ])), secondPassphrase);
        }
        this._id = utils_1.getId(this.getBytes());
    }
    getBasicBytes() {
        const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);
        const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);
        transactionTimestamp.writeIntBE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);
        const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);
        return Buffer.concat([
            transactionType,
            transactionTimestamp,
            transactionSenderPublicKey,
            this.assetToBytes(),
        ]);
    }
    assetToJSON() {
        return this.asset;
    }
    assetToBytes() {
        return Buffer.from(JSON.stringify(this.asset), 'utf-8');
    }
    _verify(sender) {
        const transactionBytes = this.getBasicBytes();
        if (this._networkIdentifier === undefined ||
            this._networkIdentifier === '') {
            throw new Error('Network identifier is required to verify a transaction ');
        }
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        const secondSignatureTxBytes = Buffer.concat([
            transactionWithNetworkIdentifierBytes,
            lisk_cryptography_1.hexToBuffer(this.signature),
        ]);
        return [
            utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey),
            utils_1.verifyBalance(this.id, sender, this.fee),
            utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes),
        ].filter(Boolean);
    }
    _validateSchema() {
        const transaction = this.toJSON();
        const schemaErrors = lisk_validator_1.validator.validate(schemas.baseTransaction, transaction);
        const errors = errors_1.convertToTransactionError(this.id, schemaErrors);
        if (!errors.find((err) => err.dataPath === '.senderPublicKey')) {
            const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);
            if (senderIdError) {
                errors.push(senderIdError);
            }
        }
        return errors;
    }
}
exports.BaseTransaction = BaseTransaction;
BaseTransaction.FEE = '0';
//# sourceMappingURL=base_transaction.js.map