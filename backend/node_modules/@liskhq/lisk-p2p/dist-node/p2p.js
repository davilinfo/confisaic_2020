"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const events_1 = require("events");
const http = require("http");
const socketcluster_server_1 = require("socketcluster-server");
const url = require("url");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const events_2 = require("./events");
const peer_book_1 = require("./peer_book");
const peer_pool_1 = require("./peer_pool");
const utils_1 = require("./utils");
const BASE_10_RADIX = 10;
const createPeerPoolConfig = (config, peerLists) => ({
    connectTimeout: config.connectTimeout,
    ackTimeout: config.ackTimeout,
    wsMaxPayload: config.wsMaxPayload
        ? config.wsMaxPayload
        : constants_1.DEFAULT_WS_MAX_PAYLOAD,
    peerSelectionForSend: config.peerSelectionForSend
        ? config.peerSelectionForSend
        : utils_1.selectPeersForSend,
    peerSelectionForRequest: config.peerSelectionForRequest
        ? config.peerSelectionForRequest
        : utils_1.selectPeersForRequest,
    peerSelectionForConnection: config.peerSelectionForConnection
        ? config.peerSelectionForConnection
        : utils_1.selectPeersForConnection,
    sendPeerLimit: config.sendPeerLimit === undefined
        ? constants_1.DEFAULT_SEND_PEER_LIMIT
        : config.sendPeerLimit,
    peerBanTime: config.peerBanTime ? config.peerBanTime : constants_1.DEFAULT_BAN_TIME,
    maxOutboundConnections: config.maxOutboundConnections === undefined
        ? constants_1.DEFAULT_MAX_OUTBOUND_CONNECTIONS
        : config.maxOutboundConnections,
    maxInboundConnections: config.maxInboundConnections === undefined
        ? constants_1.DEFAULT_MAX_INBOUND_CONNECTIONS
        : config.maxInboundConnections,
    maxPeerDiscoveryResponseLength: config.maxPeerDiscoveryResponseLength === undefined
        ? constants_1.DEFAULT_MAX_PEER_DISCOVERY_RESPONSE_LENGTH
        : config.maxPeerDiscoveryResponseLength,
    maxPeerInfoSize: config.maxPeerInfoSize
        ? config.maxPeerInfoSize
        : constants_1.DEFAULT_MAX_PEER_INFO_SIZE,
    outboundShuffleInterval: config.outboundShuffleInterval
        ? config.outboundShuffleInterval
        : constants_1.DEFAULT_OUTBOUND_SHUFFLE_INTERVAL,
    netgroupProtectionRatio: typeof config.netgroupProtectionRatio === 'number'
        ? config.netgroupProtectionRatio
        : constants_1.DEFAULT_PEER_PROTECTION_FOR_NETGROUP,
    latencyProtectionRatio: typeof config.latencyProtectionRatio === 'number'
        ? config.latencyProtectionRatio
        : constants_1.DEFAULT_PEER_PROTECTION_FOR_LATENCY,
    productivityProtectionRatio: typeof config.productivityProtectionRatio === 'number'
        ? config.productivityProtectionRatio
        : constants_1.DEFAULT_PEER_PROTECTION_FOR_USEFULNESS,
    longevityProtectionRatio: typeof config.longevityProtectionRatio === 'number'
        ? config.longevityProtectionRatio
        : constants_1.DEFAULT_PEER_PROTECTION_FOR_LONGEVITY,
    wsMaxMessageRate: typeof config.wsMaxMessageRate === 'number'
        ? config.wsMaxMessageRate
        : constants_1.DEFAULT_WS_MAX_MESSAGE_RATE,
    wsMaxMessageRatePenalty: typeof config.wsMaxMessageRatePenalty === 'number'
        ? config.wsMaxMessageRatePenalty
        : constants_1.DEFAULT_WS_MAX_MESSAGE_RATE_PENALTY,
    rateCalculationInterval: typeof config.rateCalculationInterval === 'number'
        ? config.rateCalculationInterval
        : constants_1.DEFAULT_RATE_CALCULATION_INTERVAL,
    secret: config.secret ? config.secret : constants_1.DEFAULT_RANDOM_SECRET,
    peerLists,
});
class P2P extends events_1.EventEmitter {
    constructor(config) {
        super();
        this._secret = config.secret ? config.secret : constants_1.DEFAULT_RANDOM_SECRET;
        this._sanitizedPeerLists = utils_1.sanitizePeerLists({
            seedPeers: config.seedPeers
                ? config.seedPeers.map(utils_1.sanitizeInitialPeerInfo)
                : [],
            blacklistedIPs: config.blacklistedIPs ? config.blacklistedIPs : [],
            fixedPeers: config.fixedPeers
                ? config.fixedPeers.map(utils_1.sanitizeInitialPeerInfo)
                : [],
            whitelisted: config.whitelistedPeers
                ? config.whitelistedPeers.map(utils_1.sanitizeInitialPeerInfo)
                : [],
            previousPeers: config.previousPeers
                ? config.previousPeers.map(utils_1.sanitizeInitialPeerInfo)
                : [],
        }, {
            peerId: utils_1.constructPeerId(config.hostIp || constants_1.DEFAULT_NODE_HOST_IP, config.nodeInfo.wsPort),
            ipAddress: config.hostIp || constants_1.DEFAULT_NODE_HOST_IP,
            wsPort: config.nodeInfo.wsPort,
        }, this._secret);
        this._config = config;
        this._isActive = false;
        this._hasConnected = false;
        this._peerBook = new peer_book_1.PeerBook({
            secret: this._secret,
        });
        this._initializePeerBook();
        this._bannedPeers = new Set();
        this._httpServer = http.createServer();
        this._scServer = socketcluster_server_1.attach(this._httpServer, {
            path: constants_1.DEFAULT_HTTP_PATH,
            wsEngineServerOptions: {
                maxPayload: config.wsMaxPayload
                    ? config.wsMaxPayload
                    : constants_1.DEFAULT_WS_MAX_PAYLOAD,
            },
        });
        this._handlePeerPoolRPC = (request) => {
            switch (request.procedure) {
                case events_2.REMOTE_EVENT_RPC_GET_PEERS_LIST:
                    this._handleGetPeersRequest(request);
                    break;
                case events_2.REMOTE_EVENT_RPC_GET_NODE_INFO:
                    this._handleGetNodeInfo(request);
                    break;
                default:
            }
            this.emit(events_2.EVENT_REQUEST_RECEIVED, request);
        };
        this._handlePeerPoolMessage = (message) => {
            this.emit(events_2.EVENT_MESSAGE_RECEIVED, message);
        };
        this._handleOutboundPeerConnect = (peerInfo) => {
            if (!this._peerBook.hasPeer(peerInfo)) {
                this._peerBook.addPeer(this._assignPeerKind(peerInfo));
            }
            this._peerBook.upgradePeer(peerInfo);
            this.emit(events_2.EVENT_CONNECT_OUTBOUND, peerInfo);
            if (this._isNetworkReady()) {
                this.emit(events_2.EVENT_NETWORK_READY);
            }
        };
        this._handleOutboundPeerConnectAbort = (peerInfo) => {
            if (this._peerBook.hasPeer(peerInfo) &&
                peerInfo.internalState.peerKind !==
                    constants_1.PeerKind.WHITELISTED_PEER) {
                this._peerBook.downgradePeer(peerInfo);
            }
            this.emit(events_2.EVENT_CONNECT_ABORT_OUTBOUND, peerInfo);
        };
        this._handlePeerCloseOutbound = (closePacket) => {
            const { peerInfo } = closePacket;
            if (this._peerBook.getPeer(closePacket.peerInfo)) {
                const updatedPeer = {
                    ...peerInfo,
                    internalState: utils_1.assignInternalInfo(peerInfo, this._secret),
                };
                this._peerBook.updatePeer(updatedPeer);
            }
            this.emit(events_2.EVENT_CLOSE_OUTBOUND, closePacket);
        };
        this._handlePeerCloseInbound = (closePacket) => {
            const { peerInfo } = closePacket;
            if (this._peerBook.getPeer(closePacket.peerInfo)) {
                const updatedPeer = {
                    ...peerInfo,
                    internalState: utils_1.assignInternalInfo(peerInfo, this._secret),
                };
                this._peerBook.updatePeer(updatedPeer);
            }
            this.emit(events_2.EVENT_CLOSE_INBOUND, closePacket);
        };
        this._handleRemovePeer = (peerId) => {
            this.emit(events_2.EVENT_REMOVE_PEER, peerId);
        };
        this._handlePeerInfoUpdate = (peerInfo) => {
            if (!this._peerBook.hasPeer(peerInfo)) {
                this._peerBook.addPeer(this._assignPeerKind(peerInfo));
            }
            const isUpdated = this._peerBook.updatePeer(peerInfo);
            if (isUpdated) {
                this._peerBook.upgradePeer(peerInfo);
                this.emit(events_2.EVENT_UPDATED_PEER_INFO, peerInfo);
            }
        };
        this._handleFailedPeerInfoUpdate = (error) => {
            this.emit(events_2.EVENT_FAILED_PEER_INFO_UPDATE, error);
        };
        this._handleFailedToFetchPeerInfo = (error) => {
            this.emit(events_2.EVENT_FAILED_TO_FETCH_PEER_INFO, error);
        };
        this._handleFailedToFetchPeers = (error) => {
            this.emit(events_2.EVENT_FAILED_TO_FETCH_PEERS, error);
        };
        this._handleFailedToCollectPeerDetails = (error) => {
            this.emit(events_2.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, error);
        };
        this._handleBanPeer = (peerId) => {
            this._bannedPeers.add(peerId.split(':')[0]);
            const isWhitelisted = this._sanitizedPeerLists.whitelisted.find(peer => peer.peerId === peerId);
            const bannedPeerInfo = {
                ipAddress: peerId.split(':')[0],
                wsPort: +peerId.split(':')[1],
            };
            if (this._peerBook.hasPeer({
                ipAddress: bannedPeerInfo.ipAddress,
                wsPort: bannedPeerInfo.wsPort,
                peerId,
            }) &&
                !isWhitelisted) {
                this._peerBook.removePeer({
                    ipAddress: bannedPeerInfo.ipAddress,
                    wsPort: bannedPeerInfo.wsPort,
                    peerId,
                });
            }
            this.emit(events_2.EVENT_BAN_PEER, peerId);
        };
        this._handleUnbanPeer = (peerId) => {
            this._bannedPeers.delete(peerId.split(':')[0]);
            this.emit(events_2.EVENT_UNBAN_PEER, peerId);
        };
        this._handleDiscoveredPeer = (detailedPeerInfo) => {
            const isBlacklisted = this._sanitizedPeerLists.blacklistedIPs.find(blacklistedIP => blacklistedIP === detailedPeerInfo.ipAddress);
            if (!this._peerBook.hasPeer(detailedPeerInfo) && !isBlacklisted) {
                this._peerBook.addPeer(this._assignPeerKind(detailedPeerInfo));
                this.emit(events_2.EVENT_DISCOVERED_PEER, detailedPeerInfo);
                if (!this._peerPool.hasPeer(detailedPeerInfo.peerId)) {
                    const isUpdated = this._peerBook.updatePeer(detailedPeerInfo);
                    if (isUpdated) {
                        this._peerBook.upgradePeer(detailedPeerInfo);
                    }
                }
            }
        };
        this._handleFailedToPushNodeInfo = (error) => {
            this.emit(events_2.EVENT_FAILED_TO_PUSH_NODE_INFO, error);
        };
        this._handleFailedToSendMessage = (error) => {
            this.emit(events_2.EVENT_FAILED_TO_SEND_MESSAGE, error);
        };
        this._handleOutboundSocketError = (error) => {
            this.emit(events_2.EVENT_OUTBOUND_SOCKET_ERROR, error);
        };
        this._handleInboundSocketError = (error) => {
            this.emit(events_2.EVENT_INBOUND_SOCKET_ERROR, error);
        };
        const peerPoolConfig = createPeerPoolConfig(config, this._sanitizedPeerLists);
        this._peerPool = new peer_pool_1.PeerPool(peerPoolConfig);
        this._bindHandlersToPeerPool(this._peerPool);
        this._nodeInfo = {
            ...config.nodeInfo,
            nonce: lisk_cryptography_1.getRandomBytes(constants_1.DEFAULT_NONCE_LENGTH_BYTES).toString('hex'),
        };
        this.applyNodeInfo(this._nodeInfo);
        this._populatorInterval = config.populatorInterval
            ? config.populatorInterval
            : constants_1.DEFAULT_POPULATOR_INTERVAL;
        this._fallbackSeedPeerDiscoveryInterval = config.fallbackSeedPeerDiscoveryInterval
            ? config.fallbackSeedPeerDiscoveryInterval
            : constants_1.DEFAULT_FALLBACK_SEED_PEER_DISCOVERY_INTERVAL;
        this._nextSeedPeerDiscovery =
            Date.now() + this._fallbackSeedPeerDiscoveryInterval;
        this._peerHandshakeCheck = config.peerHandshakeCheck
            ? config.peerHandshakeCheck
            : utils_1.validatePeerCompatibility;
    }
    get config() {
        return this._config;
    }
    get isActive() {
        return this._isActive;
    }
    applyNodeInfo(nodeInfo) {
        utils_1.validateNodeInfo(nodeInfo, this._config.maxPeerInfoSize
            ? this._config.maxPeerInfoSize
            : constants_1.DEFAULT_MAX_PEER_INFO_SIZE);
        this._nodeInfo = {
            ...nodeInfo,
            nonce: this.nodeInfo.nonce,
        };
        this._peerPool.applyNodeInfo(this._nodeInfo);
    }
    get nodeInfo() {
        return this._nodeInfo;
    }
    applyPenalty(peerPenalty) {
        if (!this._isTrustedPeer(peerPenalty.peerId)) {
            this._peerPool.applyPenalty(peerPenalty);
        }
    }
    getTriedPeers() {
        return this._peerBook.triedPeers.map(peer => ({
            ...peer.sharedState,
            ipAddress: peer.ipAddress,
            wsPort: peer.wsPort,
        }));
    }
    getConnectedPeers() {
        return this._peerPool
            .getAllConnectedPeerInfos()
            .filter(peer => !(peer.internalState && !peer.internalState.advertiseAddress))
            .map(peer => ({
            ...peer.sharedState,
            ipAddress: peer.ipAddress,
            wsPort: peer.wsPort,
            peerId: peer.peerId,
        }));
    }
    getDisconnectedPeers() {
        const allPeers = this._peerBook.allPeers;
        const connectedPeers = this.getConnectedPeers();
        const disconnectedPeers = allPeers.filter(peer => {
            if (connectedPeers.find(connectedPeer => peer.peerId === connectedPeer.peerId)) {
                return false;
            }
            return true;
        });
        return disconnectedPeers
            .filter(peer => !(peer.internalState && !peer.internalState.advertiseAddress))
            .map(peer => ({
            ...peer.sharedState,
            ipAddress: peer.ipAddress,
            wsPort: peer.wsPort,
            peerId: peer.peerId,
        }));
    }
    async request(packet) {
        const response = await this._peerPool.request(packet);
        return response;
    }
    send(message) {
        this._peerPool.send(message);
    }
    broadcast(message) {
        this._peerPool.broadcast(message);
    }
    async requestFromPeer(packet, peerId) {
        return this._peerPool.requestFromPeer(packet, peerId);
    }
    sendToPeer(message, peerId) {
        this._peerPool.sendToPeer(message, peerId);
    }
    _disconnectSocketDueToFailedHandshake(socket, statusCode, closeReason) {
        socket.disconnect(statusCode, closeReason);
        this.emit(events_2.EVENT_FAILED_TO_ADD_INBOUND_PEER, new errors_1.PeerInboundHandshakeError(closeReason, statusCode, socket.remoteAddress, socket.request.url));
    }
    _assignPeerKind(peerInfo) {
        if (this._sanitizedPeerLists.blacklistedIPs.find(blacklistedIP => blacklistedIP === peerInfo.ipAddress)) {
            return {
                ...peerInfo,
                internalState: {
                    ...utils_1.assignInternalInfo(peerInfo, this._secret),
                    peerKind: constants_1.PeerKind.BLACKLISTED_PEER,
                },
            };
        }
        if (this._sanitizedPeerLists.fixedPeers.find(peer => peer.ipAddress === peerInfo.ipAddress)) {
            return {
                ...peerInfo,
                internalState: {
                    ...utils_1.assignInternalInfo(peerInfo, this._secret),
                    peerKind: constants_1.PeerKind.FIXED_PEER,
                },
            };
        }
        if (this._sanitizedPeerLists.whitelisted.find(peer => peer.ipAddress === peerInfo.ipAddress)) {
            return {
                ...peerInfo,
                internalState: {
                    ...utils_1.assignInternalInfo(peerInfo, this._secret),
                    peerKind: constants_1.PeerKind.WHITELISTED_PEER,
                },
            };
        }
        if (this._sanitizedPeerLists.seedPeers.find(peer => peer.ipAddress === peerInfo.ipAddress)) {
            return {
                ...peerInfo,
                internalState: {
                    ...utils_1.assignInternalInfo(peerInfo, this._secret),
                    peerKind: constants_1.PeerKind.SEED_PEER,
                },
            };
        }
        return {
            ...peerInfo,
            internalState: {
                ...utils_1.assignInternalInfo(peerInfo, this._secret),
                peerKind: constants_1.PeerKind.NONE,
            },
        };
    }
    async _startPeerServer() {
        this._scServer.on('handshake', (socket) => {
            socket.socket.on('ping', () => {
                socket.socket.terminate();
                return;
            });
            socket.socket.on('pong', () => {
                socket.socket.terminate();
                return;
            });
            if (this._bannedPeers.has(socket.remoteAddress)) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.FORBIDDEN_CONNECTION, constants_1.FORBIDDEN_CONNECTION_REASON);
                return;
            }
            if (this._sanitizedPeerLists.blacklistedIPs) {
                if (this._sanitizedPeerLists.blacklistedIPs.includes(socket.remoteAddress)) {
                    this._disconnectSocketDueToFailedHandshake(socket, constants_1.FORBIDDEN_CONNECTION, constants_1.FORBIDDEN_CONNECTION_REASON);
                    return;
                }
            }
        });
        this._scServer.on('connection', (socket) => {
            if (!socket.request.url) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_URL_CODE, constants_1.INVALID_CONNECTION_URL_REASON);
                return;
            }
            const queryObject = url.parse(socket.request.url, true).query;
            if (queryObject.nonce === this._nodeInfo.nonce) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_SELF_CODE, constants_1.INVALID_CONNECTION_SELF_REASON);
                const selfWSPort = queryObject.wsPort
                    ? +queryObject.wsPort
                    : this._nodeInfo.wsPort;
                this._peerBook.removePeer({
                    peerId: utils_1.constructPeerId(socket.remoteAddress, selfWSPort),
                    ipAddress: socket.remoteAddress,
                    wsPort: selfWSPort,
                });
                return;
            }
            if (typeof queryObject.wsPort !== 'string' ||
                typeof queryObject.version !== 'string' ||
                typeof queryObject.networkId !== 'string') {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_QUERY_CODE, constants_1.INVALID_CONNECTION_QUERY_REASON);
                return;
            }
            const remoteWSPort = parseInt(queryObject.wsPort, BASE_10_RADIX);
            const peerId = utils_1.constructPeerId(socket.remoteAddress, remoteWSPort);
            let queryOptions;
            try {
                queryOptions =
                    typeof queryObject.options === 'string'
                        ? JSON.parse(queryObject.options)
                        : undefined;
            }
            catch (error) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_QUERY_CODE, constants_1.INVALID_CONNECTION_QUERY_REASON);
                return;
            }
            const { wsPort, ipAddress, advertiseAddress, ...restOfQueryObject } = queryObject;
            const peerInPeerBook = this._peerBook.getPeer({
                peerId,
                ipAddress: socket.remoteAddress,
                wsPort: remoteWSPort,
            });
            const incomingPeerInfo = peerInPeerBook
                ? {
                    ...peerInPeerBook,
                    internalState: {
                        ...(peerInPeerBook.internalState
                            ? peerInPeerBook.internalState
                            : utils_1.assignInternalInfo(peerInPeerBook, this._secret)),
                        advertiseAddress: advertiseAddress !== 'false',
                        connectionKind: constants_1.ConnectionKind.INBOUND,
                    },
                }
                : this._assignPeerKind({
                    sharedState: {
                        ...restOfQueryObject,
                        ...queryOptions,
                        height: queryObject.height ? +queryObject.height : 0,
                        protocolVersion: queryObject.protocolVersion,
                    },
                    internalState: {
                        ...utils_1.assignInternalInfo({
                            peerId,
                            ipAddress: socket.remoteAddress,
                            wsPort: remoteWSPort,
                        }, this._secret),
                        advertiseAddress: advertiseAddress !== 'false',
                        connectionKind: constants_1.ConnectionKind.INBOUND,
                    },
                    peerId,
                    ipAddress: socket.remoteAddress,
                    wsPort: remoteWSPort,
                });
            try {
                utils_1.validatePeerInfo(incomingPeerInfo, this._config.maxPeerInfoSize
                    ? this._config.maxPeerInfoSize
                    : constants_1.DEFAULT_MAX_PEER_INFO_SIZE);
            }
            catch (error) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_INFO_CODE, error);
            }
            const { success, error } = this._peerHandshakeCheck(incomingPeerInfo, this._nodeInfo);
            if (!success) {
                const incompatibilityReason = error || constants_1.INCOMPATIBLE_PEER_UNKNOWN_REASON;
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_CODE, incompatibilityReason);
                return;
            }
            try {
                this._peerPool.addInboundPeer(incomingPeerInfo, socket);
                this.emit(events_2.EVENT_NEW_INBOUND_PEER, incomingPeerInfo);
            }
            catch (err) {
                this._disconnectSocketDueToFailedHandshake(socket, constants_1.DUPLICATE_CONNECTION, constants_1.DUPLICATE_CONNECTION_REASON);
                return;
            }
            if (this._peerBook.hasPeer(incomingPeerInfo)) {
                return;
            }
            this._peerBook.addPeer({
                ...incomingPeerInfo,
                sourceAddress: socket.remoteAddress,
            });
        });
        this._httpServer.listen(this._nodeInfo.wsPort, this._config.hostIp || constants_1.DEFAULT_NODE_HOST_IP);
        if (this._scServer.isReady) {
            this._isActive = true;
            return;
        }
        return new Promise(resolve => {
            this._scServer.once('ready', () => {
                this._isActive = true;
                resolve();
            });
        });
    }
    async _stopHTTPServer() {
        return new Promise(resolve => {
            this._httpServer.close(() => {
                resolve();
            });
        });
    }
    async _stopWSServer() {
        return new Promise(resolve => {
            this._scServer.close(() => {
                resolve();
            });
        });
    }
    async _stopPeerServer() {
        await this._stopWSServer();
        await this._stopHTTPServer();
    }
    _startPopulator() {
        if (this._populatorIntervalId) {
            throw new Error('Populator is already running');
        }
        this._populatorIntervalId = setInterval(() => {
            this._peerPool.triggerNewConnections(this._peerBook.newPeers, this._peerBook.triedPeers);
            if (this._nextSeedPeerDiscovery < Date.now() &&
                this._peerPool.getFreeOutboundSlots() > 0) {
                this._peerPool.discoverFromSeedPeers();
                this._nextSeedPeerDiscovery =
                    Date.now() + this._fallbackSeedPeerDiscoveryInterval;
            }
        }, this._populatorInterval);
        this._peerPool.triggerNewConnections(this._peerBook.newPeers, this._peerBook.triedPeers);
    }
    _stopPopulator() {
        if (this._populatorIntervalId) {
            clearInterval(this._populatorIntervalId);
        }
    }
    _isNetworkReady() {
        if (!this._hasConnected && this._peerPool.getConnectedPeers().length > 0) {
            this._hasConnected = true;
            return true;
        }
        return false;
    }
    _handleGetPeersRequest(request) {
        const minimumPeerDiscoveryThreshold = this._config
            .minimumPeerDiscoveryThreshold
            ? this._config.minimumPeerDiscoveryThreshold
            : constants_1.DEFAULT_MIN_PEER_DISCOVERY_THRESHOLD;
        const maxPeerDiscoveryResponseLength = this._config
            .maxPeerDiscoveryResponseLength
            ? this._config.maxPeerDiscoveryResponseLength
            : constants_1.DEFAULT_MAX_PEER_DISCOVERY_RESPONSE_LENGTH;
        const wsMaxPayload = this._config.wsMaxPayload
            ? this._config.wsMaxPayload
            : constants_1.DEFAULT_WS_MAX_PAYLOAD;
        const maxPeerInfoSize = this._config.maxPeerInfoSize
            ? this._config.maxPeerInfoSize
            : constants_1.DEFAULT_MAX_PEER_INFO_SIZE;
        const safeMaxPeerInfoLength = Math.floor(constants_1.DEFAULT_WS_MAX_PAYLOAD / maxPeerInfoSize) - 1;
        const selectedPeers = this._peerBook.getRandomizedPeerList(minimumPeerDiscoveryThreshold, maxPeerDiscoveryResponseLength);
        const sanitizedPeerInfoList = selectedPeers
            .filter(peer => !(peer.internalState && !peer.internalState.advertiseAddress))
            .map(peer => ({
            ipAddress: peer.ipAddress,
            wsPort: peer.wsPort,
            ...peer.sharedState,
        }));
        request.end({
            success: true,
            peers: utils_1.getByteSize(sanitizedPeerInfoList) < wsMaxPayload
                ? sanitizedPeerInfoList
                : sanitizedPeerInfoList.slice(0, safeMaxPeerInfoLength),
        });
    }
    _handleGetNodeInfo(request) {
        request.end(this._nodeInfo);
    }
    _isTrustedPeer(peerId) {
        const isSeed = this._sanitizedPeerLists.seedPeers.find(seedPeer => peerId === seedPeer.peerId);
        const isWhitelisted = this._sanitizedPeerLists.whitelisted.find(peer => peer.peerId === peerId);
        const isFixed = this._sanitizedPeerLists.fixedPeers.find(peer => peer.peerId === peerId);
        return !!isSeed || !!isWhitelisted || !!isFixed;
    }
    _initializePeerBook() {
        const newPeersToAdd = [
            ...this._sanitizedPeerLists.fixedPeers,
            ...this._sanitizedPeerLists.whitelisted,
            ...this._sanitizedPeerLists.previousPeers,
        ];
        newPeersToAdd.forEach(peerInfo => {
            if (!this._peerBook.hasPeer(peerInfo)) {
                this._peerBook.addPeer(this._assignPeerKind(peerInfo));
            }
            this._peerBook.upgradePeer(peerInfo);
        });
    }
    async start() {
        if (this._isActive) {
            throw new Error('Node cannot start because it is already active.');
        }
        await this._startPeerServer();
        if (this._isActive) {
            if (this._peerBook.triedPeers.length < constants_1.DEFAULT_MIN_TRIED_PEER_COUNT) {
                this._peerPool.discoverFromSeedPeers();
                this._nextSeedPeerDiscovery =
                    Date.now() + this._fallbackSeedPeerDiscoveryInterval;
            }
            this._startPopulator();
        }
    }
    async stop() {
        if (!this._isActive) {
            throw new Error('Node cannot be stopped because it is not active.');
        }
        this._isActive = false;
        this._hasConnected = false;
        this._stopPopulator();
        this._peerPool.removeAllPeers();
        await this._stopPeerServer();
    }
    _bindHandlersToPeerPool(peerPool) {
        peerPool.on(events_2.EVENT_REQUEST_RECEIVED, this._handlePeerPoolRPC);
        peerPool.on(events_2.EVENT_MESSAGE_RECEIVED, this._handlePeerPoolMessage);
        peerPool.on(events_2.EVENT_CONNECT_OUTBOUND, this._handleOutboundPeerConnect);
        peerPool.on(events_2.EVENT_CONNECT_ABORT_OUTBOUND, this._handleOutboundPeerConnectAbort);
        peerPool.on(events_2.EVENT_CLOSE_INBOUND, this._handlePeerCloseInbound);
        peerPool.on(events_2.EVENT_CLOSE_OUTBOUND, this._handlePeerCloseOutbound);
        peerPool.on(events_2.EVENT_REMOVE_PEER, this._handleRemovePeer);
        peerPool.on(events_2.EVENT_UPDATED_PEER_INFO, this._handlePeerInfoUpdate);
        peerPool.on(events_2.EVENT_FAILED_PEER_INFO_UPDATE, this._handleFailedPeerInfoUpdate);
        peerPool.on(events_2.EVENT_FAILED_TO_FETCH_PEER_INFO, this._handleFailedToFetchPeerInfo);
        peerPool.on(events_2.EVENT_FAILED_TO_FETCH_PEERS, this._handleFailedToFetchPeers);
        peerPool.on(events_2.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, this._handleFailedToCollectPeerDetails);
        peerPool.on(events_2.EVENT_DISCOVERED_PEER, this._handleDiscoveredPeer);
        peerPool.on(events_2.EVENT_FAILED_TO_PUSH_NODE_INFO, this._handleFailedToPushNodeInfo);
        peerPool.on(events_2.EVENT_FAILED_TO_SEND_MESSAGE, this._handleFailedToSendMessage);
        peerPool.on(events_2.EVENT_OUTBOUND_SOCKET_ERROR, this._handleOutboundSocketError);
        peerPool.on(events_2.EVENT_INBOUND_SOCKET_ERROR, this._handleInboundSocketError);
        peerPool.on(events_2.EVENT_BAN_PEER, this._handleBanPeer);
        peerPool.on(events_2.EVENT_UNBAN_PEER, this._handleUnbanPeer);
    }
}
exports.P2P = P2P;
//# sourceMappingURL=p2p.js.map