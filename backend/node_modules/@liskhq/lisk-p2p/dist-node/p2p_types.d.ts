import { ConnectionKind, PeerKind } from './constants';
export interface P2PRequestPacket {
    readonly data?: unknown;
    readonly procedure: string;
}
export interface P2PResponsePacket {
    readonly peerId?: string;
    readonly data: unknown;
}
export interface P2PMessagePacket {
    readonly peerId?: string;
    readonly data?: unknown;
    readonly event: string;
}
export interface P2PClosePacket {
    readonly peerInfo: P2PPeerInfo;
    readonly code: number;
    readonly reason?: string;
}
export interface P2PPenalty {
    readonly peerId: string;
    readonly penalty: number;
}
export interface P2PSharedState {
    readonly [key: string]: unknown;
}
export interface P2PInternalState {
    dateAdded?: Date;
    peerKind: PeerKind;
    productivity: {
        requestCounter: number;
        responseCounter: number;
        responseRate: number;
        lastResponded: number;
    };
    reputation: number;
    netgroup: number;
    latency: number;
    connectTime: number;
    messageCounter: Map<string, number>;
    messageRates: Map<string, number>;
    rpcCounter: Map<string, number>;
    rpcRates: Map<string, number>;
    wsMessageCount: number;
    wsMessageRate: number;
    connectionKind: ConnectionKind;
    advertiseAddress: boolean;
}
export interface P2PPeerInfo {
    readonly peerId: string;
    readonly ipAddress: string;
    readonly wsPort: number;
    readonly sharedState?: P2PSharedState;
    readonly internalState?: P2PInternalState;
}
export declare type P2PEnhancedPeerInfo = {
    readonly dateAdded?: Date;
    readonly numOfConnectionFailures?: number;
    readonly sourceAddress?: string;
    readonly bucketId?: number;
} & P2PPeerInfo;
export interface P2PPeersCount {
    readonly outboundCount: number;
    readonly inboundCount: number;
}
export interface P2PNodeInfo extends P2PSharedState {
    readonly protocolVersion: string;
    readonly os: string;
    readonly networkId: string;
    readonly wsPort: number;
    readonly advertiseAddress: boolean;
    readonly nonce: string;
}
export interface ProtocolPeerInfo {
    readonly ipAddress: string;
    readonly wsPort: number;
    readonly [key: string]: unknown;
}
export interface P2PConfig {
    readonly blacklistedIPs?: ReadonlyArray<string>;
    readonly seedPeers?: ReadonlyArray<ProtocolPeerInfo>;
    readonly fixedPeers?: ReadonlyArray<ProtocolPeerInfo>;
    readonly whitelistedPeers?: ReadonlyArray<ProtocolPeerInfo>;
    readonly previousPeers?: ReadonlyArray<ProtocolPeerInfo>;
    readonly connectTimeout?: number;
    readonly ackTimeout?: number;
    readonly nodeInfo: P2PNodeInfo;
    readonly populatorInterval?: number;
    readonly fallbackSeedPeerDiscoveryInterval?: number;
    readonly maxOutboundConnections: number;
    readonly maxInboundConnections: number;
    readonly wsMaxPayload?: number;
    readonly peerSelectionForSend?: P2PPeerSelectionForSendFunction;
    readonly peerSelectionForRequest?: P2PPeerSelectionForRequestFunction;
    readonly peerSelectionForConnection?: P2PPeerSelectionForConnectionFunction;
    readonly peerHandshakeCheck?: P2PCheckPeerCompatibility;
    readonly peerBanTime?: number;
    readonly sendPeerLimit?: number;
    readonly outboundShuffleInterval?: number;
    readonly latencyProtectionRatio?: number;
    readonly productivityProtectionRatio?: number;
    readonly longevityProtectionRatio?: number;
    readonly netgroupProtectionRatio?: number;
    readonly hostIp?: string;
    readonly wsMaxMessageRate?: number;
    readonly wsMaxMessageRatePenalty?: number;
    readonly rateCalculationInterval?: number;
    readonly minimumPeerDiscoveryThreshold?: number;
    readonly maxPeerDiscoveryResponseLength?: number;
    readonly maxPeerInfoSize?: number;
    readonly secret?: number;
}
export interface P2PPeerSelectionForSendInput {
    readonly peers: ReadonlyArray<P2PPeerInfo>;
    readonly nodeInfo?: P2PNodeInfo;
    readonly peerLimit?: number;
    readonly messagePacket?: P2PMessagePacket;
}
export declare type P2PPeerSelectionForSendFunction = (input: P2PPeerSelectionForSendInput) => ReadonlyArray<P2PPeerInfo>;
export interface P2PPeerSelectionForRequestInput {
    readonly peers: ReadonlyArray<P2PPeerInfo>;
    readonly nodeInfo?: P2PNodeInfo;
    readonly peerLimit?: number;
    readonly requestPacket?: P2PRequestPacket;
}
export declare type P2PPeerSelectionForRequestFunction = (input: P2PPeerSelectionForRequestInput) => ReadonlyArray<P2PPeerInfo>;
export interface P2PPeerSelectionForConnectionInput {
    readonly newPeers: ReadonlyArray<P2PPeerInfo>;
    readonly triedPeers: ReadonlyArray<P2PPeerInfo>;
    readonly nodeInfo?: P2PNodeInfo;
    readonly peerLimit?: number;
}
export declare type P2PPeerSelectionForConnectionFunction = (input: P2PPeerSelectionForConnectionInput) => ReadonlyArray<P2PPeerInfo>;
export interface P2PCompatibilityCheckReturnType {
    readonly success: boolean;
    readonly error?: string;
}
export declare type P2PCheckPeerCompatibility = (headers: P2PPeerInfo, nodeInfo: P2PNodeInfo) => P2PCompatibilityCheckReturnType;
export interface PeerLists {
    readonly blacklistedIPs: ReadonlyArray<string>;
    readonly seedPeers: ReadonlyArray<P2PPeerInfo>;
    readonly fixedPeers: ReadonlyArray<P2PPeerInfo>;
    readonly whitelisted: ReadonlyArray<P2PPeerInfo>;
    readonly previousPeers: ReadonlyArray<P2PPeerInfo>;
}
