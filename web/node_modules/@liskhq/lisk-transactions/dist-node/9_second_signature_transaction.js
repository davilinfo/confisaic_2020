"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const base_transaction_1 = require("./base_transaction");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
exports.secondSignatureAssetFormatSchema = {
    type: 'object',
    required: ['publicKey'],
    properties: {
        publicKey: {
            type: 'string',
            format: 'publicKey',
        },
    },
};
class SecondSignatureTransaction extends base_transaction_1.BaseTransaction {
    constructor(rawTransaction) {
        super(rawTransaction);
        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null
            ? rawTransaction
            : {});
        this.asset = (tx.asset || { signature: {} });
    }
    assetToBytes() {
        const { publicKey } = this.asset;
        return lisk_cryptography_1.hexToBuffer(publicKey);
    }
    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId,
            },
        ]);
    }
    verifyAgainstTransactions(transactions) {
        return transactions
            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)
            .map(tx => new errors_1.TransactionError('Register second signature only allowed once per account.', tx.id, '.asset.signature'));
    }
    validateAsset() {
        const schemaErrors = lisk_validator_1.validator.validate(exports.secondSignatureAssetFormatSchema, this.asset);
        const errors = errors_1.convertToAssetError(this.id, schemaErrors);
        return errors;
    }
    applyAsset(store) {
        const errors = [];
        const sender = store.account.get(this.senderId);
        if (sender.secondPublicKey) {
            errors.push(new errors_1.TransactionError('Register second signature only allowed once per account.', this.id, '.secondPublicKey'));
        }
        const updatedSender = {
            ...sender,
            secondPublicKey: this.asset.publicKey,
            secondSignature: 1,
        };
        store.account.set(updatedSender.address, updatedSender);
        return errors;
    }
    undoAsset(store) {
        const sender = store.account.get(this.senderId);
        const resetSender = {
            ...sender,
            secondPublicKey: null,
            secondSignature: 0,
        };
        store.account.set(resetSender.address, resetSender);
        return [];
    }
    sign(passphrase) {
        this._signature = undefined;
        this._signSignature = undefined;
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            this.getBytes(),
        ]);
        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(transactionWithNetworkIdentifierBytes), passphrase);
        this._id = utils_1.getId(this.getBytes());
    }
}
exports.SecondSignatureTransaction = SecondSignatureTransaction;
SecondSignatureTransaction.TYPE = 9;
SecondSignatureTransaction.FEE = constants_1.SIGNATURE_FEE.toString();
//# sourceMappingURL=9_second_signature_transaction.js.map