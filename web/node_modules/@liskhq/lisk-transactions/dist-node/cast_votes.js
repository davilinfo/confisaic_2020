"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const _11_vote_transaction_1 = require("./11_vote_transaction");
const utils_1 = require("./utils");
const validateInputs = ({ votes = [], unvotes = [], networkIdentifier, }) => {
    if (!Array.isArray(votes)) {
        throw new Error('Please provide a valid votes value. Expected an array if present.');
    }
    if (!Array.isArray(unvotes)) {
        throw new Error('Please provide a valid unvotes value. Expected an array if present.');
    }
    lisk_validator_1.validatePublicKeys([...votes, ...unvotes]);
    lisk_validator_1.validateNetworkIdentifier(networkIdentifier);
};
exports.castVotes = (inputs) => {
    validateInputs(inputs);
    const { networkIdentifier, passphrase, secondPassphrase, votes = [], unvotes = [], } = inputs;
    const plusPrependedVotes = utils_1.prependPlusToPublicKeys(votes);
    const minusPrependedUnvotes = utils_1.prependMinusToPublicKeys(unvotes);
    const allVotes = [
        ...plusPrependedVotes,
        ...minusPrependedUnvotes,
    ];
    const transaction = {
        ...utils_1.createBaseTransaction(inputs),
        type: 11,
        asset: {
            amount: '0',
            votes: allVotes,
        },
    };
    if (!passphrase) {
        return transaction;
    }
    const recipientId = lisk_cryptography_1.getAddressFromPassphrase(passphrase);
    const transactionWithSenderInfo = {
        ...transaction,
        senderPublicKey: transaction.senderPublicKey,
        asset: {
            ...transaction.asset,
            recipientId,
        },
        networkIdentifier,
    };
    const voteTransaction = new _11_vote_transaction_1.VoteTransaction(transactionWithSenderInfo);
    voteTransaction.sign(passphrase, secondPassphrase);
    return voteTransaction.toJSON();
};
//# sourceMappingURL=cast_votes.js.map