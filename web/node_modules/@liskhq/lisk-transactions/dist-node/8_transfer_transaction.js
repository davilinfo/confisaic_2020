"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BigNum = require("@liskhq/bignum");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const base_transaction_1 = require("./base_transaction");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
exports.transferAssetFormatSchema = {
    type: 'object',
    required: ['recipientId', 'amount'],
    properties: {
        recipientId: {
            type: 'string',
            format: 'address',
        },
        amount: {
            type: 'string',
            format: 'amount',
        },
        data: {
            type: 'string',
            format: 'transferData',
            maxLength: 64,
        },
    },
};
class TransferTransaction extends base_transaction_1.BaseTransaction {
    constructor(rawTransaction) {
        super(rawTransaction);
        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null
            ? rawTransaction
            : {});
        if (tx.asset) {
            const rawAsset = tx.asset;
            this.asset = {
                data: rawAsset.data,
                recipientId: rawAsset.recipientId,
                amount: new BigNum(lisk_validator_1.isPositiveNumberString(rawAsset.amount) ? rawAsset.amount : '0'),
            };
        }
        else {
            this.asset = {
                amount: new BigNum('0'),
                recipientId: '',
            };
        }
    }
    assetToBytes() {
        const transactionAmount = lisk_cryptography_1.bigNumberToBuffer(this.asset.amount.toString(), constants_1.BYTESIZES.AMOUNT, 'big');
        const transactionRecipientID = this.asset.recipientId
            ? lisk_cryptography_1.intToBuffer(this.asset.recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID).slice(0, constants_1.BYTESIZES.RECIPIENT_ID)
            : Buffer.alloc(0);
        const dataBuffer = this.asset.data
            ? lisk_cryptography_1.stringToBuffer(this.asset.data)
            : Buffer.alloc(0);
        return Buffer.concat([
            transactionAmount,
            transactionRecipientID,
            dataBuffer,
        ]);
    }
    assetToJSON() {
        return {
            data: this.asset.data,
            amount: this.asset.amount.toString(),
            recipientId: this.asset.recipientId,
        };
    }
    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId,
            },
            {
                address: this.asset.recipientId,
            },
        ]);
    }
    validateAsset() {
        const asset = this.assetToJSON();
        const schemaErrors = lisk_validator_1.validator.validate(exports.transferAssetFormatSchema, asset);
        const errors = errors_1.convertToAssetError(this.id, schemaErrors);
        if (!lisk_validator_1.isValidTransferAmount(this.asset.amount.toString())) {
            errors.push(new errors_1.TransactionError('Amount must be a valid number in string format.', this.id, '.asset.amount', this.asset.amount.toString()));
        }
        if (!this.asset.recipientId) {
            errors.push(new errors_1.TransactionError('`recipientId` must be provided.', this.id, '.asset.recipientId'));
        }
        return errors;
    }
    applyAsset(store) {
        const errors = [];
        const sender = store.account.get(this.senderId);
        const balanceError = utils_1.verifyAmountBalance(this.id, sender, this.asset.amount, this.fee);
        if (balanceError) {
            errors.push(balanceError);
        }
        const updatedSenderBalance = new BigNum(sender.balance).sub(this.asset.amount);
        const updatedSender = {
            ...sender,
            balance: updatedSenderBalance.toString(),
        };
        store.account.set(updatedSender.address, updatedSender);
        const recipient = store.account.getOrDefault(this.asset.recipientId);
        const updatedRecipientBalance = new BigNum(recipient.balance).add(this.asset.amount);
        if (updatedRecipientBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {
            errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.asset.amount.toString()));
        }
        const updatedRecipient = {
            ...recipient,
            balance: updatedRecipientBalance.toString(),
        };
        store.account.set(updatedRecipient.address, updatedRecipient);
        return errors;
    }
    undoAsset(store) {
        const errors = [];
        const sender = store.account.get(this.senderId);
        const updatedSenderBalance = new BigNum(sender.balance).add(this.asset.amount);
        if (updatedSenderBalance.gt(constants_1.MAX_TRANSACTION_AMOUNT)) {
            errors.push(new errors_1.TransactionError('Invalid amount', this.id, '.amount', this.asset.amount.toString()));
        }
        const updatedSender = {
            ...sender,
            balance: updatedSenderBalance.toString(),
        };
        store.account.set(updatedSender.address, updatedSender);
        const recipient = store.account.getOrDefault(this.asset.recipientId);
        const balanceError = utils_1.verifyBalance(this.id, recipient, this.asset.amount);
        if (balanceError) {
            errors.push(balanceError);
        }
        const updatedRecipientBalance = new BigNum(recipient.balance).sub(this.asset.amount);
        const updatedRecipient = {
            ...recipient,
            balance: updatedRecipientBalance.toString(),
        };
        store.account.set(updatedRecipient.address, updatedRecipient);
        return errors;
    }
}
exports.TransferTransaction = TransferTransaction;
TransferTransaction.TYPE = 8;
TransferTransaction.FEE = constants_1.TRANSFER_FEE.toString();
//# sourceMappingURL=8_transfer_transaction.js.map