"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const _8_transfer_transaction_1 = require("./8_transfer_transaction");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const validateInputs = ({ amount, recipientId, recipientPublicKey, data, networkIdentifier, }) => {
    if (!lisk_validator_1.isValidTransferAmount(amount)) {
        throw new Error('Amount must be a valid number in string format.');
    }
    if (!recipientId && !recipientPublicKey) {
        throw new Error('Either recipientId or recipientPublicKey must be provided.');
    }
    if (typeof recipientId !== 'undefined') {
        lisk_validator_1.validateAddress(recipientId);
    }
    if (typeof recipientPublicKey !== 'undefined') {
        lisk_validator_1.validatePublicKey(recipientPublicKey);
    }
    if (recipientId &&
        recipientPublicKey &&
        recipientId !== lisk_cryptography_1.getAddressFromPublicKey(recipientPublicKey)) {
        throw new Error('recipientId does not match recipientPublicKey.');
    }
    if (data && data.length > 0) {
        if (typeof data !== 'string') {
            throw new Error('Invalid encoding in transaction data. Data must be utf-8 encoded string.');
        }
        if (data.length > constants_1.BYTESIZES.DATA) {
            throw new Error('Transaction data field cannot exceed 64 bytes.');
        }
    }
    lisk_validator_1.validateNetworkIdentifier(networkIdentifier);
};
exports.transfer = (inputs) => {
    validateInputs(inputs);
    const { data, amount, recipientPublicKey, passphrase, secondPassphrase, networkIdentifier, } = inputs;
    const recipientIdFromPublicKey = recipientPublicKey
        ? lisk_cryptography_1.getAddressFromPublicKey(recipientPublicKey)
        : undefined;
    const recipientId = inputs.recipientId
        ? inputs.recipientId
        : recipientIdFromPublicKey;
    const transaction = {
        ...utils_1.createBaseTransaction(inputs),
        type: 8,
        asset: {
            amount,
            recipientId: recipientId,
            data,
        },
    };
    if (!passphrase) {
        return transaction;
    }
    const transactionWithSenderInfo = {
        ...transaction,
        networkIdentifier,
        senderPublicKey: transaction.senderPublicKey,
        asset: {
            ...transaction.asset,
            recipientId: recipientId,
        },
    };
    const transferTransaction = new _8_transfer_transaction_1.TransferTransaction(transactionWithSenderInfo);
    transferTransaction.sign(passphrase, secondPassphrase);
    return transferTransaction.toJSON();
};
//# sourceMappingURL=transfer.js.map