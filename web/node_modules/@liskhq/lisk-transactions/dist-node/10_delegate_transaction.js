"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lisk_validator_1 = require("@liskhq/lisk-validator");
const base_transaction_1 = require("./base_transaction");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
exports.delegateAssetFormatSchema = {
    type: 'object',
    required: ['username'],
    properties: {
        username: {
            type: 'string',
            minLength: 1,
            maxLength: 20,
            format: 'username',
        },
    },
};
class DelegateTransaction extends base_transaction_1.BaseTransaction {
    constructor(rawTransaction) {
        super(rawTransaction);
        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null
            ? rawTransaction
            : {});
        this.asset = (tx.asset || { delegate: {} });
        this.containsUniqueData = true;
    }
    assetToBytes() {
        const { username } = this.asset;
        return Buffer.from(username, 'utf8');
    }
    async prepare(store) {
        await store.account.cache([
            {
                address: this.senderId,
            },
            {
                username: this.asset.username,
            },
        ]);
    }
    verifyAgainstTransactions(transactions) {
        return transactions
            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)
            .map(tx => new errors_1.TransactionError('Register delegate only allowed once per account.', tx.id, '.asset.delegate'));
    }
    validateAsset() {
        const schemaErrors = lisk_validator_1.validator.validate(exports.delegateAssetFormatSchema, this.asset);
        const errors = errors_1.convertToAssetError(this.id, schemaErrors);
        return errors;
    }
    applyAsset(store) {
        const errors = [];
        const sender = store.account.get(this.senderId);
        const usernameExists = store.account.find((account) => account.username === this.asset.username);
        if (usernameExists) {
            errors.push(new errors_1.TransactionError(`Username is not unique.`, this.id, '.asset.username'));
        }
        if (sender.isDelegate || sender.username) {
            errors.push(new errors_1.TransactionError('Account is already a delegate', this.id, '.asset.username'));
        }
        const updatedSender = {
            ...sender,
            username: this.asset.username,
            vote: 0,
            isDelegate: 1,
        };
        store.account.set(updatedSender.address, updatedSender);
        return errors;
    }
    undoAsset(store) {
        const sender = store.account.get(this.senderId);
        const { username, ...strippedSender } = sender;
        const resetSender = {
            ...sender,
            username: null,
            vote: 0,
            isDelegate: 0,
        };
        store.account.set(strippedSender.address, resetSender);
        return [];
    }
}
exports.DelegateTransaction = DelegateTransaction;
DelegateTransaction.TYPE = 10;
DelegateTransaction.FEE = constants_1.DELEGATE_FEE.toString();
//# sourceMappingURL=10_delegate_transaction.js.map