"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BigNum = require("@liskhq/bignum");
const lisk_cryptography_1 = require("@liskhq/lisk-cryptography");
const lisk_validator_1 = require("@liskhq/lisk-validator");
const base_transaction_1 = require("./base_transaction");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const response_1 = require("./response");
const utils_1 = require("./utils");
exports.multisignatureAssetFormatSchema = {
    type: 'object',
    required: ['min', 'lifetime', 'keysgroup'],
    properties: {
        min: {
            type: 'integer',
            minimum: 1,
            maximum: 15,
        },
        lifetime: {
            type: 'integer',
            minimum: 1,
            maximum: 72,
        },
        keysgroup: {
            type: 'array',
            uniqueItems: true,
            minItems: 1,
            maxItems: 15,
            items: {
                type: 'string',
                format: 'additionPublicKey',
            },
        },
    },
};
const setMemberAccounts = (store, membersPublicKeys) => {
    membersPublicKeys.forEach(memberPublicKey => {
        const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);
        const memberAccount = store.account.getOrDefault(address);
        const memberAccountWithPublicKey = {
            ...memberAccount,
            publicKey: memberAccount.publicKey || memberPublicKey,
        };
        store.account.set(memberAccount.address, memberAccountWithPublicKey);
    });
};
const extractPublicKeysFromAsset = (assetPublicKeys) => assetPublicKeys.map(key => key.substring(1));
class MultisignatureTransaction extends base_transaction_1.BaseTransaction {
    constructor(rawTransaction) {
        super(rawTransaction);
        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;
        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null
            ? rawTransaction
            : {});
        this.asset = (tx.asset || {});
        this.fee = new BigNum(MultisignatureTransaction.FEE).mul((this.asset.keysgroup && this.asset.keysgroup.length
            ? this.asset.keysgroup.length
            : 0) + 1);
    }
    assetToBytes() {
        const { min, lifetime, keysgroup } = this.asset;
        const minBuffer = Buffer.alloc(1, min);
        const lifetimeBuffer = Buffer.alloc(1, lifetime);
        const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');
        return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);
    }
    async prepare(store) {
        const membersAddresses = extractPublicKeysFromAsset(this.asset.keysgroup).map(publicKey => ({ address: lisk_cryptography_1.getAddressFromPublicKey(publicKey) }));
        await store.account.cache([
            {
                address: this.senderId,
            },
            ...membersAddresses,
        ]);
    }
    verifyAgainstTransactions(transactions) {
        const errors = transactions
            .filter(tx => tx.type === this.type && tx.senderPublicKey === this.senderPublicKey)
            .map(tx => new errors_1.TransactionError('Register multisignature only allowed once per account.', tx.id, '.asset.multisignature'));
        return errors;
    }
    validateAsset() {
        const schemaErrors = lisk_validator_1.validator.validate(exports.multisignatureAssetFormatSchema, this.asset);
        const errors = errors_1.convertToAssetError(this.id, schemaErrors);
        if (errors.length > 0) {
            return errors;
        }
        if (this.asset.min > this.asset.keysgroup.length) {
            errors.push(new errors_1.TransactionError('Invalid multisignature min. Must be less than or equal to keysgroup size', this.id, '.asset.min', this.asset.min));
        }
        return errors;
    }
    processMultisignatures(_) {
        const transactionBytes = this.getBasicBytes();
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        const { valid, errors } = utils_1.validateMultisignatures(this.asset.keysgroup.map(signedPublicKey => signedPublicKey.substring(1)), this.signatures, this.asset.keysgroup.length, transactionWithNetworkIdentifierBytes, this.id);
        if (valid) {
            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.READY;
            return response_1.createResponse(this.id, errors);
        }
        if (errors &&
            errors.length === 1 &&
            errors[0] instanceof errors_1.TransactionPendingError) {
            this._multisignatureStatus = base_transaction_1.MultisignatureStatus.PENDING;
            return {
                id: this.id,
                status: response_1.Status.PENDING,
                errors,
            };
        }
        this._multisignatureStatus = base_transaction_1.MultisignatureStatus.FAIL;
        return response_1.createResponse(this.id, errors);
    }
    applyAsset(store) {
        const errors = [];
        const sender = store.account.get(this.senderId);
        if (sender.membersPublicKeys && sender.membersPublicKeys.length > 0) {
            errors.push(new errors_1.TransactionError('Register multisignature only allowed once per account.', this.id, '.signatures'));
        }
        if (this.asset.keysgroup.includes(`+${sender.publicKey}`)) {
            errors.push(new errors_1.TransactionError('Invalid multisignature keysgroup. Can not contain sender', this.id, '.signatures'));
        }
        const updatedSender = {
            ...sender,
            membersPublicKeys: extractPublicKeysFromAsset(this.asset.keysgroup),
            multiMin: this.asset.min,
            multiLifetime: this.asset.lifetime,
        };
        store.account.set(updatedSender.address, updatedSender);
        setMemberAccounts(store, updatedSender.membersPublicKeys);
        return errors;
    }
    undoAsset(store) {
        const sender = store.account.get(this.senderId);
        const resetSender = {
            ...sender,
            membersPublicKeys: [],
            multiMin: 0,
            multiLifetime: 0,
        };
        store.account.set(resetSender.address, resetSender);
        return [];
    }
    addMultisignature(store, signatureObject) {
        const keysgroup = this.asset.keysgroup.map((aKey) => aKey.slice(1));
        if (!keysgroup.includes(signatureObject.publicKey)) {
            return response_1.createResponse(this.id, [
                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member.`, this.id),
            ]);
        }
        if (this.signatures.includes(signatureObject.signature)) {
            return response_1.createResponse(this.id, [
                new errors_1.TransactionError('Encountered duplicate signature in transaction', this.id),
            ]);
        }
        const transactionBytes = this.getBasicBytes();
        const networkIdentifierBytes = lisk_cryptography_1.hexToBuffer(this._networkIdentifier);
        const transactionWithNetworkIdentifierBytes = Buffer.concat([
            networkIdentifierBytes,
            transactionBytes,
        ]);
        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, transactionWithNetworkIdentifierBytes, this.id);
        if (valid) {
            this.signatures.push(signatureObject.signature);
            return this.processMultisignatures(store);
        }
        const errors = valid
            ? []
            : [
                new errors_1.TransactionError(`Failed to add signature ${signatureObject.signature}.`, this.id, '.signatures'),
            ];
        return response_1.createResponse(this.id, errors);
    }
}
exports.MultisignatureTransaction = MultisignatureTransaction;
MultisignatureTransaction.TYPE = 12;
MultisignatureTransaction.FEE = constants_1.MULTISIGNATURE_FEE.toString();
//# sourceMappingURL=12_multisignature_transaction.js.map